<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>horsed.github.io
    </title>
    <link rel="alternate" href="http://horsed.github.io/feed.xml" type="application/rss+xml" title="Tooling, learning">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic|Anonymous+Pro:400,700,400italic,700italic|Merriweather:400,700,300">
    <link rel="stylesheet" href="/css/main.css">
  </head>
  <body>
    <header class="header">
      <div class="content-wrap">
        <div class="logo">
          <h1><a href="http://horsed.github.io">horsed.github.io</a></h1>
          <p class="description">Tooling, learning</p>
        </div>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article intro">
          <header>
            <p class="date"><span>30. January 2014</span></p>
            <h2><a href="/articles/introducing-bowerproxy/">Fetching bower packages via a RESTful API</a></h2>
          </header>
          <section class="content"><p>When starting to use <a href="http://angularjs.org/">AngularJS</a> at work, I soon had to realize, that using <a href="http://bower.io/">Bower</a> might not be an option. Bower fetches components from <a href="https://github.com/">GitHub</a> with <code>SSH</code>, which got blocked by the corporate proxy. If Bower was able to fetch with <code>HTTPS</code>, everything would have been fine. Of course, easing the security restriction was not an option :-)<br>Instead of arguing about the proxy and why Bower didn’t seem to have a proxy configuration, I quickly hacked together a simple Node webapp to fetch Bower components with. It runs on <a href="https://www.heroku.com/">heroku</a>. The idea was to <code>curl</code> a component from that webapp, which then actually fetches the component via <a href="http://bower.io/#programmatic-api">Bower’s <span class="caps">API</span></a> and zips it. I curled and unziped via a shell script. Pretty simple. The only thing missing was automatically editing the <code>bower.json</code>, which doesn’t seem too difficult.<br>The hardest part about that webapp was making it failsafe. The earliest versions crashed when Bower threw an error (like it does when you request a component that doesn’t exist) and I’m not sure why, but I wasn’t able to catch those errors. I learned about Node’s <a href="http://nodejs.org/api/domain.html">domain module</a> which was kind of hard figure out at first but really helped with the error handling.<br>I’m not using the app today anymore, nor am I coding on it. It was just one of a few small projects I started to do something that is new and interesting at least for 2 or 3 evenings.<br>Anyway, here is some code about that tricky error handling with nested <code>domains</code>:</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> search = bower.commands.search(packageName, {});

<span class="keyword">var</span> d = domain.create();
d.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> {</span>
  errFn(err);
});
d.add(search);

d.run(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  search.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(results)</span> {</span>
    <span class="keyword">if</span>(results.length &gt; <span class="number">0</span>) {
      <span class="keyword">var</span> install = bower.commands.install(
        packageName,
        {save:<span class="literal">false</span>},
        {cwd: <span class="string">"output"</span>, directory: <span class="string">"bower_components"</span>});

      <span class="keyword">var</span> d = domain.create();
      d.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> {</span>
        errFn(err);
      });
      d.add(install);

      d.run(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        install.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span><span class="params">(installed)</span> {</span>
          <span class="comment">// do something            </span>
        });
      });
    } <span class="keyword">else</span> {
      errFn(<span class="string">'package '</span> + packageName + <span class="string">' not found'</span>);
    }
  });
});
</code></pre>
<p>The <code>bower.commands</code> <code>search</code> and <code>install</code> are <code>EventEmitters</code> and in this example <code>install</code> is created inside an event handler of <code>search</code>. Using <code>domain</code> for error handling requires you to add all <code>EventEmitters</code> being used inside the <code>domain.run(function() {})</code> function to the domain <strong>before</strong> the run function gets set. <code>install</code> is created inside of <code>search.on(&#39;end&#39;,...</code> which in turn is executed in the outer <code>domain</code>. That means, <code>install</code> can’t be added to the outer domain anymore. It has to be used inside another <code>domain</code>. That’s why there is an inner <code>domain</code>.</p>

          </section>
        </article>
        <article class="article intro">
          <header>
            <p class="date"><span>18. December 2013</span></p>
            <h2><a href="/articles/angularjs-learnings-custom-jquery-events-in-a-dsl/">Trigger jQuery events in a custom dsl</a></h2>
          </header>
          <section class="content"><p>When developing dynamic frontends with jQuery you will most likely be making use of events (e.g. mouseover). In AngularJS this event handling code usually lies in directives. When it comes to testing these directives in e2e tests, you may want to trigger some of these events. Angular uses it’s jqLite for e2e test where you might be looking first for some events you can trigger. But since jqLite is only a subset of jquery it doesn’t provide all events supported by&nbsp;jquery.</p>
<p>I wanted to e2e test a directive which shows and hides another element when hovering over the directive’s element. I wrote a custom dsl to trigger the <code>mouseover</code> event on a given element. But the event didn’t seem to fire inside the e2e tests although it worked in the browser. Here is the&nbsp;code:</p>
<pre><code class="lang-html"><span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"master"</span> <span class="attribute">show-hide</span>=<span class="value">".slave"</span>&gt;</span>...<span class="tag">&lt;/<span class="title">span</span>&gt;</span>
<span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"slave"</span>&gt;</span>...<span class="tag">&lt;/<span class="title">span</span>&gt;</span>
</code></pre>
<p>The e2e test looked like&nbsp;this:</p>
<pre><code class="lang-javascript">angular.scenario.dsl(<span class="string">'mouseover'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(selector)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.addFutureAction(<span class="string">'Calling mouseover of given element'</span>, <span class="function"><span class="keyword">function</span><span class="params">($window, $document, done)</span> {</span>
      $document.find(selector).trigger(<span class="string">'mouseover'</span>);
      done();
    });
  };
});

...

it(<span class="string">'should show slave'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  expect(element(<span class="string">'.slave'</span>).css(<span class="string">'display'</span>)).toBe(<span class="string">'none'</span>);

  mouseover(<span class="string">'.master'</span>);

  expect(element(<span class="string">'.slave'</span>).css(<span class="string">'display'</span>)).not().toBe(<span class="string">'none'</span>);
});
</code></pre>
<p>The problem is with using jQuery in the custom dsl. What I understood so far is that angular’s Scenario Runner runs your app in an iFrame which lies inside a main frame. The main frame has jQuery available, as the Scenario Runner depends on it. So I thought there were no restrictions in using jQuery in a custom dsl. However, the outer jQuery instance cannot bubble up events inside the <span class="caps">DOM</span> of the iFrame. So calling <code>trigger</code> with my custom dsl had no effect inside the&nbsp;iFrame.</p>
<p>Here is what made it&nbsp;work:</p>
<pre><code class="lang-javascript">angular.scenario.dsl(<span class="string">'mouseover'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(selector)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.addFutureAction(<span class="string">'Calling mouseover of given element'</span>, <span class="function"><span class="keyword">function</span><span class="params">($window, $document, done)</span> {</span>
      <span class="keyword">var</span> elements = $window.angular.element($document.elements());
      elements.trigger(<span class="string">'mouseover'</span>);
      done();
    });
  };
});
</code></pre>
<p>You can find some explanatory code <a href="https://github.com/angular/angular.js/pull/752">here</a>.</p>

          </section>
        </article>
        <article class="article intro">
          <header>
            <p class="date"><span>19. November 2013</span></p>
            <h2><a href="/articles/angularjs-learnings-be-careful-using-ngmin/">Minification vs. Dependency Injection</a></h2>
          </header>
          <section class="content"><p>AngularJS brings Dependency Injection into your app. But if you apply minification during your build process, you have to take care of not breaking your&nbsp;<span class="caps">DI</span>.</p>
<p>If you’re using <a href="http://yeoman.io/">yeoman</a> to generate your AngularJS project you’re probably making use of <a href="http://gruntjs.com/">grunt</a> to build everything. The default build configuration runs <a href="https://github.com/btford/ngmin">ngmin</a> for pre-minification of your script files. That means you will have to stick to some conventions for writing controllers, services, filters etc. Take a look at <code>ngmin</code>. This is what I ran&nbsp;into:</p>
<p>I defined a controller by hand like&nbsp;this:</p>
<pre><code class="lang-javascript"><span class="function"><span class="keyword">function</span> <span class="title">MainCtrl</span> <span class="params">($scope, $routeParams)</span> {</span>
  ...
}
</code></pre>
<p>and it got minfied&nbsp;to</p>
<pre><code class="lang-javascript"><span class="function"><span class="keyword">function</span> <span class="title">MainCtrl</span> <span class="params">(a, b)</span> {</span>
  ...
}
</code></pre>
<p>This breaks AngularJSs’ Depedency Injection. So I had to rewrite this&nbsp;to:</p>
<pre><code class="lang-javascript">angular.module(<span class="string">'phvApp'</span>)
  .controller(<span class="string">'MainCtrl'</span>, [<span class="string">'$scope'</span>, <span class="string">'$routeParams'</span>,
    <span class="function"><span class="keyword">function</span> <span class="params">($scope, $routeParams)</span> {</span>
    ...
  }]);
</code></pre>

          </section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="/archive.html">« Archives</a><a href="/page/2/">Next page »</a>
        </div>
        <section class="about">
        </section>
        <section class="copy">
          <p>&copy; 2014 Martin Knopf &mdash; powered by&nbsp;<a href="https://github.com/jnordberg/wintersmith">Wintersmith</a>
          </p>
        </section>
      </div>
    </footer>
  </body>
</html>